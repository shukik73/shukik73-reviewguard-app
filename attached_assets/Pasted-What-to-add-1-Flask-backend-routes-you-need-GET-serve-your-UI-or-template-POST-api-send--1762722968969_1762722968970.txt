What to add
1) Flask backend (routes you need)

GET / → serve your UI (or template)

POST /api/send → send SMS via Twilio, save message to DB

POST /api/upload → handle RO photo → OCR → parse customer

GET /api/history → list recent messages

GET /api/customers + POST /api/customers

POST /webhooks/twilio-status → delivery status updates

POST /stripe/create-checkout-session → start subscription

POST /stripe/webhook → keep tenant subscription states current

Use SQLite (built-in on Replit) for speed, or migrate later. Simple multi-tenant: each record carries account_id, which you set after Stripe checkout.

2) Stripe model (simple & scalable)

Tiered subscription (e.g., $49 Starter = 300 SMS/mo, $99 Pro = 1,000 SMS/mo).

Optional metered add-on (e.g., $0.03 per SMS overage) OR hard-limit + upsell.

Flow:

User hits /billing → click “Subscribe”.

Your FE calls /stripe/create-checkout-session.

Stripe Checkout → success returns to /app?sub=active.

Stripe webhook sets account.status=active, saves stripe_customer_id, stripe_subscription_id, and plan’s SMS limit.

Middleware checks status before allowing /api/send.

Minimal Flask skeleton (drop in app.py)
import os, sqlite3, json
from flask import Flask, request, jsonify, send_from_directory
from twilio.rest import Client as TwilioClient
import stripe

app = Flask(__name__)

# --- Config (set in Replit Secrets) ---
STRIPE_API_KEY = os.environ.get("STRIPE_API_KEY")
STRIPE_PRICE_ID = os.environ.get("STRIPE_PRICE_ID")  # e.g. price_xxx (monthly)
STRIPE_WEBHOOK_SECRET = os.environ.get("STRIPE_WEBHOOK_SECRET")
TWILIO_SID = os.environ.get("TWILIO_SID")
TWILIO_AUTH = os.environ.get("TWILIO_AUTH")
TWILIO_FROM = os.environ.get("TWILIO_FROM")  # your sending number
APP_BASE_URL = os.environ.get("APP_BASE_URL")  # your repl URL

stripe.api_key = STRIPE_API_KEY
twilio = TwilioClient(TWILIO_SID, TWILIO_AUTH)

DB = "data.db"

def db():
    conn = sqlite3.connect(DB)
    conn.row_factory = sqlite3.Row
    return conn

def init_db():
    with db() as con:
        con.executescript("""
        CREATE TABLE IF NOT EXISTS accounts(
          id INTEGER PRIMARY KEY,
          email TEXT,
          status TEXT DEFAULT 'trial', -- 'trial'|'active'|'past_due'|'canceled'
          stripe_customer_id TEXT,
          stripe_subscription_id TEXT,
          sms_quota INTEGER DEFAULT 300,
          sms_sent INTEGER DEFAULT 0
        );
        CREATE TABLE IF NOT EXISTS customers(
          id INTEGER PRIMARY KEY,
          account_id INTEGER,
          name TEXT,
          phone TEXT,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );
        CREATE TABLE IF NOT EXISTS messages(
          id INTEGER PRIMARY KEY,
          account_id INTEGER,
          to_phone TEXT,
          body TEXT,
          media_url TEXT,
          twilio_sid TEXT,
          status TEXT,
          type TEXT, -- 'review'|'pickup'
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );
        """)
init_db()

# --- VERY simple auth placeholder (replace with real login) ---
def current_account_id():
    # For MVP, accept ?account_id=1 or header X-Account-ID
    return int(request.headers.get("X-Account-ID") or request.args.get("account_id", "1"))

def check_billing_ok(account_id):
    with db() as con:
        row = con.execute("SELECT status, sms_quota, sms_sent FROM accounts WHERE id=?",
                          (account_id,)).fetchone()
        if not row:
            return False, "no-account"
        if row["status"] not in ("active", "trial"):
            return False, "inactive"
        if row["sms_sent"] >= row["sms_quota"]:
            return False, "quota-exceeded"
        return True, None

@app.route("/")
def index():
    # If your UI is static, serve index.html
    return send_from_directory("static", "index.html")

@app.route("/api/customers", methods=["GET","POST"])
def customers():
    acc = current_account_id()
    with db() as con:
        if request.method == "POST":
            data = request.json
            con.execute("INSERT INTO customers(account_id,name,phone) VALUES(?,?,?)",
                        (acc, data["name"], data["phone"]))
            con.commit()
            return jsonify({"ok": True})
        rows = con.execute("SELECT * FROM customers WHERE account_id=? ORDER BY id DESC", (acc,)).fetchall()
        return jsonify([dict(r) for r in rows])

@app.route("/api/history")
def history():
    acc = current_account_id()
    with db() as con:
        rows = con.execute(
            "SELECT id,to_phone,body,status,type,created_at FROM messages WHERE account_id=? ORDER BY id DESC LIMIT 200",
            (acc,)
        ).fetchall()
        return jsonify([dict(r) for r in rows])

@app.route("/api/send", methods=["POST"])
def send_sms():
    acc = current_account_id()
    ok, reason = check_billing_ok(acc)
    if not ok:
        return jsonify({"ok": False, "error": reason}), 402

    data = request.form if request.form else request.json
    to_phone = data["phone"]
    body = data["body"]
    media_url = data.get("media_url")  # optional

    status_callback = f"{APP_BASE_URL}/webhooks/twilio-status?account_id={acc}"
    msg = twilio.messages.create(
        to=to_phone,
        from_=TWILIO_FROM,
        body=body,
        status_callback=status_callback,
        media_url=[media_url] if media_url else None
    )

    with db() as con:
        con.execute("""INSERT INTO messages(account_id,to_phone,body,media_url,twilio_sid,status,type)
                       VALUES(?,?,?,?,?,?,?)""",
                    (acc, to_phone, body, media_url, msg.sid, "queued", data.get("type","review")))
        con.execute("UPDATE accounts SET sms_sent=sms_sent+1 WHERE id=?", (acc,))
        con.commit()
    return jsonify({"ok": True, "sid": msg.sid})

@app.route("/webhooks/twilio-status", methods=["POST"])
def twilio_status():
    acc = current_account_id()
    message_sid = request.form.get("MessageSid")
    message_status = request.form.get("MessageStatus")  # queued|sent|delivered|failed
    with db() as con:
        con.execute("UPDATE messages SET status=? WHERE account_id=? AND twilio_sid=?",
                    (message_status, acc, message_sid))
        con.commit()
    return ("", 200)

# ---------- Stripe ----------
@app.route("/stripe/create-checkout-session", methods=["POST"])
def create_checkout():
    # frontend sends email (optional) and plan; MVP uses one STRIPE_PRICE_ID
    data = request.get_json() or {}
    email = data.get("email")

    session = stripe.checkout.Session.create(
        mode="subscription",
        line_items=[{"price": STRIPE_PRICE_ID, "quantity": 1}],
        success_url=f"{APP_BASE_URL}/?billing=success",
        cancel_url=f"{APP_BASE_URL}/?billing=cancel",
        customer_email=email,
        automatic_tax={"enabled": True}
    )
    return jsonify({"id": session.id, "url": session.url})

@app.route("/stripe/webhook", methods=["POST"])
def stripe_webhook():
    payload = request.data
    sig = request.headers.get("Stripe-Signature")
    try:
        event = stripe.Webhook.construct_event(payload, sig, STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        return (str(e), 400)

    if event["type"] in ("checkout.session.completed", "customer.subscription.created"):
        obj = event["data"]["object"]
        customer_id = obj.get("customer") or obj.get("customer_id")
        subscription_id = obj.get("subscription") or obj.get("id")

        with db() as con:
            # MVP: bind all to account_id=1; real app: map by email or session metadata
            con.execute("""UPDATE accounts
                           SET status='active',
                               stripe_customer_id=?,
                               stripe_subscription_id=?,
                               sms_quota=CASE WHEN ? LIKE 'price_pro%' THEN 1000 ELSE 300 END
                           WHERE id=1""",
                        (customer_id, subscription_id, STRIPE_PRICE_ID))
            con.commit()

    if event["type"] in ("customer.subscription.deleted", "invoice.payment_failed"):
        obj = event["data"]["object"]
        sub_id = obj.get("id") or obj.get("subscription")
        with db() as con:
            con.execute("UPDATE accounts SET status='past_due' WHERE stripe_subscription_id=?",
                        (sub_id,))
            con.commit()

    return ("", 200)

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8080)

Replit setup (Secrets)

Add these in Secrets:

STRIPE_API_KEY=sk_live_...
STRIPE_PRICE_ID=price_...
STRIPE_WEBHOOK_SECRET=whsec_...
TWILIO_SID=ACxxxx
TWILIO_AUTH=xxxx
TWILIO_FROM=+1xxxxxxxxxx
APP_BASE_URL=https://<your-repl-subdomain>.replit.dev

Frontend hooks (Stripe Checkout + send flow)

“Subscribe” button → POST /stripe/create-checkout-session → redirect to session.url.

After success, Stripe redirects to /?billing=success → show “Active” and enable send button.

Your Send button should call /api/send with { phone, body, type, media_url? }.

Example minimal JS:

<script>
async function subscribe(email){
  const r = await fetch('/stripe/create-checkout-session', {
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify({email})
  });
  const {url} = await r.json();
  location.href = url;
}

async function sendSMS(payload){
  const r = await fetch('/api/send', {
    method:'POST',
    headers:{'Content-Type':'application/json','X-Account-ID':'1'},
    body: JSON.stringify(payload)
  });
  const data = await r.json();
  if(!data.ok){ alert('Billing/Quota issue: '+(data.error||'unknown')); }
}
</script>

OCR for Repair Order (optional MVP)

Add /api/upload that accepts an image/PDF, uses Tesseract (pytesseract) or an LLM OCR to extract Name/Phone/Device; return JSON to pre-fill the form.

Save the parsed customer to customers and reuse from the Customers panel.

Quotas & abuse-proofing

Increment sms_sent on enqueue; decrement on Twilio failed if you want to “refund”.

Hard stop when quota is hit (return 402) and show Upgrade CTA.

Add per-tenant rate-limit (e.g., max 3 sends/minute).

Launch checklist

 Stripe test mode working (Checkout + webhooks).

 Twilio status callback returns delivered/failed in history table.

 One “review request” template with shortlink (use your Google Review URL).

 CSV import for existing customers.

 Daily usage email to tenant (sent/remaining).