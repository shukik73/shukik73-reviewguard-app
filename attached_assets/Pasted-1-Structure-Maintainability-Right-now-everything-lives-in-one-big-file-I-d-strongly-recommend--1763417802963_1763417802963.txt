1Ô∏è‚É£ Structure & Maintainability

Right now everything lives in one big file. I‚Äôd strongly recommend splitting into modules so it‚Äôs easier to grow:

Suggested folders:

src/
  server.js            // app.listen + high-level setup
  db.js                // pool + initializeDatabase()
  middleware/
    auth.js            // requireAuth, maybe isAdmin
    errorHandler.js
  routes/
    auth.js            // signup/login/logout/password reset
    sms.js             // send SMS, get history, customers
    ocr.js             // photo ‚Üí name/phone
    billing.js         // Stripe + subscriptions
    dashboard.js       // stats for Dashboard tab
  services/
    twilio.js          // sendSms(), checkQuota()
    customers.js       // findOrCreateCustomer()
    messages.js        // logMessage(), getMessages()


Then in server.js:

import authRoutes from './routes/auth.js';
import smsRoutes from './routes/sms.js';
import billingRoutes from './routes/billing.js';

app.use('/api/auth', authRoutes);
app.use('/api/sms', requireAuth, smsRoutes);
app.use('/api/billing', requireAuth, billingRoutes);


This makes it easy later to add more flows like device ready SMS, follow-ups, etc.

2Ô∏è‚É£ Security & Robustness

You‚Äôre already doing a lot right (bcrypt, session store, SSL on prod). Here‚Äôs how to tighten it further:

üîê 2.1 Session & auth

Don‚Äôt fall back to a random session secret in prod.

if (!process.env.SESSION_SECRET && process.env.NODE_ENV === 'production') {
  throw new Error('SESSION_SECRET is required in production');
}

app.use(session({
  secret: process.env.SESSION_SECRET || 'dev-secret',
  ...
}));


Add rate limiting on auth & SMS routes to avoid abuse:

import rateLimit from 'express-rate-limit';

const authLimiter = rateLimit({ windowMs: 15 * 60 * 1000, max: 20 });
const smsLimiter  = rateLimit({ windowMs: 60 * 1000, max: 5 });

app.use('/api/auth', authLimiter);
app.use('/api/sms/send', smsLimiter);


Add helmet for basic security headers:

import helmet from 'helmet';
app.use(helmet());

üì± 2.2 Phone & email validation

Right now phone is just VARCHAR(50). To avoid Twilio errors, validate on input:

import { parsePhoneNumberFromString } from 'libphonenumber-js';

function normalizePhone(phoneRaw) {
  const phone = parsePhoneNumberFromString(phoneRaw, 'US');
  if (!phone || !phone.isValid()) throw new Error('Invalid phone number');
  return phone.number; // E.164 format
}


Use this in your SMS route before inserting into customers/messages.

üíæ 2.3 Multi-tenant safety

You‚Äôve added user_id columns. Make sure every query is scoped by user_id so one shop can‚Äôt see another‚Äôs data.

Example for fetching messages:

const { rows } = await pool.query(
  `SELECT * FROM messages
   WHERE user_id = $1
   ORDER BY sent_at DESC
   LIMIT 50`,
  [req.session.userId]
);


Same for customers, subscriptions, etc.

3Ô∏è‚É£ SMS Sending Flow (make it match your app UI)

Given your UI, the ideal backend pattern is:

find or create customer

enforce quota / plan

send SMS via Twilio

log in messages table (with type, link, review_status)

You can wrap this in a helper:

import twilio from 'twilio';
const twilioClient = twilio(process.env.TWILIO_SID, process.env.TWILIO_TOKEN);

async function findOrCreateCustomer({ name, phone, userId }) {
  const normalized = normalizePhone(phone);
  const existing = await pool.query(
    'SELECT * FROM customers WHERE phone = $1 AND $2::int IS NOT NULL',
    [normalized, userId]
  );

  if (existing.rows.length) return existing.rows[0];

  const { rows } = await pool.query(
    `INSERT INTO customers (name, phone)
     VALUES ($1, $2)
     RETURNING *`,
    [name, normalized]
  );
  return rows[0];
}

async function sendSmsAndLog({ userId, name, phone, body, type, reviewLink }) {
  const customer = await findOrCreateCustomer({ name, phone, userId });

  // TODO: check subscription quota for this user before sending

  const twilioResp = await twilioClient.messages.create({
    to: phone,
    from: process.env.TWILIO_FROM,
    body
  });

  const { rows } = await pool.query(
    `INSERT INTO messages (user_id, customer_id, customer_name, customer_phone,
                           message_type, review_link, status, twilio_sid)
     VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
     RETURNING *`,
    [userId, customer.id, name, phone, type, reviewLink || null, 'sent', twilioResp.sid]
  );

  return rows[0];
}


Then your route is super clean:

app.post('/api/sms/send', requireAuth, async (req, res, next) => {
  try {
    const { customerName, customerPhone, messageType, reviewLink, additionalInfo } = req.body;

    if (!customerName || !customerPhone || !messageType) {
      return res.status(400).json({ success: false, error: 'Missing required fields' });
    }

    const body = buildMessageBody({ messageType, customerName, reviewLink, additionalInfo });
    const message = await sendSmsAndLog({
      userId: req.session.userId,
      name: customerName,
      phone: customerPhone,
      body,
      type: messageType,
      reviewLink
    });

    res.json({ success: true, message });
  } catch (err) {
    next(err);
  }
});


Where buildMessageBody(...) is just a switch for your templates.

4Ô∏è‚É£ Use sharp for thumbnails & clean uploads

You already import sharp but don‚Äôt use it yet. Perfect for your ‚Äúbefore/after‚Äù & ‚Äúrepair order‚Äù images.

When saving upload images, you can auto-generate a small web-optimized version:

app.post('/api/uploads/repair-photo', upload.single('photo'), async (req, res, next) => {
  try {
    const fullPath = req.file.path;
    const thumbPath = fullPath.replace(/(\.\w+)$/, '-thumb$1');

    await sharp(fullPath)
      .resize(800, 800, { fit: 'inside' })
      .jpeg({ quality: 80 })
      .toFile(thumbPath);

    res.json({
      success: true,
      file: {
        original: `/uploads/${path.basename(fullPath)}`,
        thumb: `/uploads/${path.basename(thumbPath)}`
      }
    });
  } catch (err) {
    next(err);
  }
});


This keeps your storage + loading times under control, especially when you start generating before/after video reels from these.

5Ô∏è‚É£ Add a central error handler

Right now, each route does catch + res.status(500).... Better pattern:

function errorHandler(err, req, res, next) {
  console.error(err);

  const status = err.status || 500;
  res.status(status).json({
    success: false,
    error: err.publicMessage || 'Something went wrong'
  });
}

app.use(errorHandler);


In routes, just next(err) and keep the logic clean.

6Ô∏è‚É£ How this ties into your UI (Dashboard / History / Customers)

Because you‚Äôve already built:

customers table

messages table

indices on sent_at, customer_id, phone

you can now easily drive your front-end tabs:

Dashboard ‚Üí SELECT COUNT(*) and grouped stats from messages for the current user_id

History ‚Üí SELECT * FROM messages WHERE user_id = $1 ORDER BY sent_at DESC LIMIT 100

Customers ‚Üí SELECT * FROM customers joined with messages for ‚Äúlast contacted‚Äù, ‚Äútotal messages‚Äù, etc.