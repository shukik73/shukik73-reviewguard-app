ğŸ§° REPLIT AGENT â€” FOLLOW THESE RULES FOR ARCHITECTURE FIXES

Before modifying anything:

Do NOT rewrite large files.

Do NOT refactor existing logic unless I approve.

Do NOT move Stripe or Twilio code.

Do NOT modify HTML/CSS/UI.

Ask before creating each new file.

Show the lines you want to extract before you extract them.

Make changes in small, atomic steps only.

ğŸ”¥ PHASE 2 FIX LIST â€” SAFE ARCHITECTURE IMPROVEMENTS

This is the cleanest and safest upgrade path.

âœ… 1. Create a /routes folder

We will slowly migrate big parts of server.js into modular route files.

Files to be created:
/routes/auth.js
/routes/sms.js
/routes/ocr.js
/routes/customers.js
/routes/feedback.js
/routes/billing.js


âš ï¸ IMPORTANT:
Do NOT move logic yet â€” only create empty files.

âœ… 2. Extract AUTH routes from server.js â†’ routes/auth.js

This includes:

/signup

/login

/logout

/reset-password

/forgot-password

Safe procedure:

Show me the auth-related code in server.js

Copy it into routes/auth.js

Use this structure:

import { Router } from "express";
const router = Router();

// signup route hereâ€¦

export default router;


After copy, import the new route into server.js:

import authRoutes from './routes/auth.js';
app.use(authRoutes);


DO NOT delete the old code yet â€” only comment it out after testing.

âœ… 3. Extract SMS routes â†’ routes/sms.js

These include:

/send-sms

any internal SMS functions

Same process:

Agent must show SMS code

Copy into routes/sms.js

Import in server.js:
app.use('/sms', smsRoutes);

Test

Comment out old code ONLY after testing

âœ… 4. Extract OCR logic â†’ routes/ocr.js

Include:

/api/extract-text

HEIC conversion

Google Vision OCR call

name/phone/device parsing

Follow same moveâ€“testâ€“comment-out pattern.

âœ… 5. Extract FEEDBACK routes â†’ routes/feedback.js

Routes:

/feedback

/review-status

anything related to responses

âœ… 6. Extract CUSTOMER routes â†’ routes/customers.js

Routes:

/customers

/customer/create

/customer/update

/customer/:id

âœ… 7. Extract BILLING routes â†’ routes/billing.js

Routes:

/billing/subscribe

/billing/portal

/billing/webhook

/billing/status

Stripe is sensitiveâ€”Agent must not modify any logic.

ğŸ§¹ 8. Create a /middleware folder

Create:

/middleware/requireLogin.js
/middleware/rateLimit.js
/middleware/errorHandler.js

requireLogin.js:
export default function requireLogin(req, res, next) {
  if (!req.session.userId) return res.redirect('/login.html');
  next();
}

rateLimit.js (simple version):
const lastSMSSent = new Map();

export function smsLimiter(req, res, next) {
  const userId = req.session.userId;
  if (!userId) return next();

  const last = lastSMSSent.get(userId);
  if (last && Date.now() - last < 3000) {
    return res.status(429).json({ error: "Wait 3 seconds before sending another SMS" });
  }

  lastSMSSent.set(userId, Date.now());
  next();
}

errorHandler.js:
export default function errorHandler(err, req, res, next) {
  console.error("Server error:", err);
  res.status(500).json({ error: "Unexpected server error" });
}

ğŸ”Œ 9. Update server.js to use structure

After routes are extracted, add:

import authRoutes from './routes/auth.js';
import smsRoutes from './routes/sms.js';
import ocrRoutes from './routes/ocr.js';
import customerRoutes from './routes/customers.js';
import feedbackRoutes from './routes/feedback.js';
import billingRoutes from './routes/billing.js';

import requireLogin from './middleware/requireLogin.js';
import { smsLimiter } from './middleware/rateLimit.js';
import errorHandler from './middleware/errorHandler.js';

app.use(authRoutes);
app.use('/sms', smsLimiter, smsRoutes);
app.use('/ocr', ocrRoutes);
app.use('/customers', requireLogin, customerRoutes);
app.use('/feedback', feedbackRoutes);
app.use('/billing', requireLogin, billingRoutes);

app.use(errorHandler);

âš ï¸ 10. Only after ALL routes work â€” clean up server.js

Agent should:

Ask permission first

Then remove old commented code

Keep the initialization + global config

ğŸš€ WHAT THIS PHASE 2 ACHIEVES
Your app becomes:

âœ” Modular
âœ” Maintainable
âœ” Safer
âœ” Cleaner
âœ” Easier to extend
âœ” Easier for multiple devs
âœ” More scalable

WITHOUT:

âŒ rewriting the whole app
âŒ breaking working features
âŒ messing with Stripe or Twilio
âŒ touching UI
âŒ losing logic
âŒ needing React or TypeScript